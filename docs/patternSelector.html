<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>パターン設定</title>
    <link rel="stylesheet" href="styles/pattern-theme.css" />
    <script>
      (function copyParentStyles(){
        function cloneStyles(){
          try {
            if (!window.opener || !window.opener.document) return;
            try {
              document.documentElement.className = window.opener.document.documentElement.className || '';
              if (document.body) document.body.className = window.opener.document.body.className || '';
            } catch {}
            const head = document.head;
            const links = window.opener.document.querySelectorAll('link[rel="stylesheet"], style');
            links.forEach(node => {
              try {
                if (node.tagName === 'LINK') {
                  const href = node.getAttribute('href');
                  if (!href) return;
                  const link = document.createElement('link');
                  link.rel = 'stylesheet';
                  link.href = href;
                  head.appendChild(link);
                } else if (node.tagName === 'STYLE') {
                  const style = document.createElement('style');
                  style.textContent = node.textContent;
                  head.appendChild(style);
                }
              } catch {}
            });
          } catch {}
        }
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', cloneStyles);
        } else {
          cloneStyles();
        }
      })();
    </script>
    <script id="patternManifest" type="application/json">[
      "assets/images/patterns/PT_01.png",
      "assets/images/patterns/PT_02.png",
      "assets/images/patterns/PT_03.png",
      "assets/images/patterns/PT_04.png",
      "assets/images/patterns/PT_05.png",
      "assets/images/patterns/PT_06.png",
      "assets/images/patterns/PT_07.png",
      "assets/images/patterns/PT_08.png",
      "assets/images/patterns/PT_09.png",
      "assets/images/patterns/PT_010.png"
    ]</script>
    <style>
      body { margin: 16px; }
      .container { max-width: 760px; margin: 0 auto; }
      h1 { font-size: 18px; margin: 0 0 12px; }
      .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; }
      .item { border: 2px solid #ddd; border-radius: 8px; overflow: hidden; cursor: pointer; position: relative; background: #f6f7f8; }
      .item.selected { border-color: #0078d4; box-shadow: 0 0 0 2px rgba(0,120,212,.2) inset; }
      /* 参考画像として一部だけをさらに拡大表示（画像は非表示にしない） */
      .item img.thumb-img {
        width: 100%;
        height: 90px;
        object-fit: cover;
        display: block;
        background: #000;
        /* ズーム倍率は必要に応じて調整 */
        transform: scale(3.5);
        transform-origin: center center;
      }
      .item canvas.thumb { display: none; width: 100%; height: 90px; background: #000; }
      .item .name { font-size: 12px; padding: 6px 8px; border-top: 1px solid #eee; background: #fafafa; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .controls { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }
      .hint { font-size: 12px; color: #555; }
      .skeleton { width: 100%; height: 90px; background: linear-gradient(90deg, #f6f7f8 0%, #edeef1 50%, #f6f7f8 100%); background-size: 200% 100%; animation: shimmer 1.2s infinite; }
      @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>パターン設定</h1>
      <div class="grid" id="patternGrid"></div>
    </div>

    <script>
      (function(){
        const grid = document.getElementById('patternGrid');
        let selected = null;

        function displayNameFromSrc(src) {
          // 項目名はファイル名のみ（拡張子付き）
          try {
            const clean = (src || '').split('?')[0].split('#')[0];
            const base = clean.split('/').pop() || clean;
            return base;
          } catch { return src; }
        }

        function toThumb(src) {
          try {
            const parts = src.split('/');
            const file = parts.pop();
            const idx = parts.lastIndexOf('patterns');
            if (idx >= 0) {
              parts.splice(idx + 1, 0, 'thumbs');
              return parts.join('/') + '/' + file;
            }
          } catch {}
          return src;
        }

        function createNoneItem() {
          const div = document.createElement('div');
          div.className = 'item';
          div.title = '';
          const sk = document.createElement('div'); sk.className = 'skeleton';
          sk.style.display = 'flex'; sk.style.alignItems = 'center'; sk.style.justifyContent = 'center'; sk.style.color = '#fff'; sk.style.fontSize = '14px'; sk.style.background = '#000';
          sk.textContent = '未設定';
          const name = document.createElement('div'); name.className = 'name'; name.textContent = '未設定';
          div.appendChild(sk); div.appendChild(name);
          div.addEventListener('dblclick', () => {
            const payload = { type: 'patternSettingApply', src: null };
            try { window.opener && window.opener.postMessage(payload, '*'); } catch {}
            window.close();
          });
          return div;
        }

        const THUMB_ZOOM = 2.0; // 拡大率（中心をトリミング表示）

        function renderCroppedThumb(url, canvas, ondone){
          const img = new Image();
          img.onload = () => {
            try {
              const dpr = window.devicePixelRatio || 1;
              const cw = canvas.clientWidth || 180;
              const ch = canvas.clientHeight || 90;
              canvas.width = Math.max(1, Math.round(cw * dpr));
              canvas.height = Math.max(1, Math.round(ch * dpr));
              const ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              const iw = img.naturalWidth || img.width;
              const ih = img.naturalHeight || img.height;
              // 中心を基準にズーム分だけ切り出し
              const zw = Math.max(1, Math.round(iw / THUMB_ZOOM));
              const zh = Math.max(1, Math.round(ih / THUMB_ZOOM));
              const sx = Math.max(0, Math.round((iw - zw) / 2));
              const sy = Math.max(0, Math.round((ih - zh) / 2));
              // キャンバスいっぱいに描画（アスペクトはキャンバス側固定）
              ctx.fillStyle = '#000';
              ctx.fillRect(0,0,canvas.width, canvas.height);
              // キャンバス比率に合わせてcover描画
              const rCanvas = canvas.width / canvas.height;
              const rCrop = zw / zh;
              let dx=0, dy=0, dw=canvas.width, dh=canvas.height;
              if (rCrop > rCanvas) {
                // 幅広 → 高さ基準
                const scaledW = Math.round(zh * rCanvas);
                const sx2 = sx + Math.max(0, Math.round((zw - scaledW) / 2));
                ctx.drawImage(img, sx2, sy, scaledW, zh, 0, 0, dw, dh);
              } else {
                // 縦長 → 幅基準
                const scaledH = Math.round(zw / rCanvas);
                const sy2 = sy + Math.max(0, Math.round((zh - scaledH) / 2));
                ctx.drawImage(img, sx, sy2, zw, scaledH, 0, 0, dw, dh);
              }
            } finally {
              if (typeof ondone === 'function') ondone();
            }
          };
          img.onerror = () => { if (typeof ondone === 'function') ondone(); };
          img.src = url;
        }

        function createItem(src) {
          const div = document.createElement('div');
          div.className = 'item';
          div.title = src;
          const sk = document.createElement('div'); sk.className = 'skeleton';
          const cvs = document.createElement('canvas');
          cvs.className = 'thumb';
          cvs.width = 240; cvs.height = 90;
          const img = document.createElement('img');
          img.className = 'thumb-img';
          img.setAttribute('loading', 'lazy');
          img.setAttribute('decoding', 'async');
          img.setAttribute('fetchpriority', 'low');
          img.dataset.src = toThumb(src);
          img.dataset.full = src;
          img.onerror = () => { if (img.dataset.triedFull !== '1') { img.dataset.triedFull = '1'; img.src = img.dataset.full; } };
          img.onload = () => { try { sk.remove(); } catch {} };
          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = displayNameFromSrc(src);
          div.appendChild(sk);
          div.appendChild(cvs);
          div.appendChild(img);
          div.appendChild(name);
          div.addEventListener('click', () => { selected = src; markSelected(src); update(); });
          return div;
        }

        function markSelected(src) {
          grid.querySelectorAll('.item').forEach(el => el.classList.toggle('selected', el.title === src));
        }

        const io = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (!entry.isIntersecting) return;
            const item = entry.target;
            const cvs = item.querySelector('canvas.thumb');
            const img = item.querySelector('img.thumb-img');
            const urlThumb = toThumb(item.title);
            // 画像の遅延読み込み（フォールバック表示）
            if (img && !img.src) img.src = urlThumb;
            // キャンバス拡大サムネ（現在は非表示。必要ならCSSで有効化）
            if (cvs) {
              renderCroppedThumb(urlThumb, cvs, () => {
                const sk = item.querySelector('.skeleton'); if (sk) sk.remove();
              });
            }
            io.unobserve(item);
          });
        }, { root: null, rootMargin: '200px', threshold: 0.01 });

        async function loadManifest() {
          try {
            if (location.protocol === 'http:' || location.protocol === 'https:') {
              const res = await fetch('assets/images/patterns/manifest.json', { cache: 'no-cache' });
              if (res.ok) {
                const arr = await res.json();
                if (Array.isArray(arr)) return arr;
              }
            }
          } catch {}
          try {
            const el = document.getElementById('patternManifest');
            if (el && el.textContent) {
              const arr = JSON.parse(el.textContent);
              if (Array.isArray(arr)) return arr;
            }
          } catch {}
          return [];
        }

        (async function init(){
          const list = await loadManifest();
          if (!list.length) {
            const hint = document.createElement('div');
            hint.className = 'hint';
            hint.textContent = 'assets/images/patterns/manifest.json またはこのページ内の patternManifest に画像パスを指定してください。';
            grid.parentNode.insertBefore(hint, grid);
          } else {
            // Add "未設定" first
            const noneItem = createNoneItem();
            grid.appendChild(noneItem);
            list.forEach(src => { const item = createItem(src); grid.appendChild(item); io.observe(item); });
          }

          // Preselect
          try {
            const sp = new URLSearchParams(location.search);
            const img = sp.get('img');
            if (img) { selected = img; markSelected(img); }
          } catch {}

          update();
        })();

        function update(){}
        // Double-click to apply
        grid.addEventListener('dblclick', (e) => {
          const item = e.target.closest('.item');
          if (!item) return;
          const payload = { type: 'patternSettingApply', src: item.title };
          try { window.opener && window.opener.postMessage(payload, '*'); } catch {}
          window.close();
        });
      })();
    </script>
  </body>
  </html>
